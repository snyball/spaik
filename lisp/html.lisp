(defun chr (s)
  (next (iter s)))

(defun escape (s)
  (or (and (or (number? s) (bool? s)) (string s))
      (and (symbol? s) (escape (string s)))
      (let ((out (vec)))
        (dolist (x s)
          (push out
                (cond ((= x (chr "<")) "&lt;")
                      ((= x (chr ">")) "&gt;")
                      ((= x (chr "&")) "&amp;")
                      (true x))))
        (apply concat out))))

(defun escape-attr (s)
  (or (and (or (number? s) (bool? s)) s)
      (and (symbol? s) s)
      (let ((out (vec)))
        (dolist (x s)
          (push out
                (cond ((= x (chr "<")) "&lt;")
                      ((= x (chr ">")) "&gt;")
                      ((= x (chr "&")) "&amp;")
                      ((= x (chr "\"")) "&quot;")
                      ((= x (chr "'")) "&#39;")
                      (true x))))
        (apply concat out))))

(defun keyword? (x)
  (and (symbol? x)
       (= (chr (string x))
          (chr ":"))))

(defun keyword-s (x)
  (let ((it (iter (string x))))
    (next it)
    (apply concat (collect it))))

(defmacro html (&body b)
  (let ((s (vec 'vec)))
    (dolist (elem b)
      (if (cons? elem)
          (progn
            (if (symbol? (car elem))
                (let ((tag (string (car elem))))
                  (push s "<")
                  (push s tag)
                  (while (keyword? (cadr elem))
                    (push s " ")
                    (push s (keyword-s (cadr elem)))
                    (set elem (cdr elem))
                    (push s "=\"")
                    (if (cons? (cadr elem))
                        (push s (cadr elem))
                      (push s (escape-attr (cadr elem))))
                    (set elem (cdr elem))
                    (push s "\""))
                  (push s ">")
                  (push s `(html ,@(cdr elem)))
                  (push s "</")
                  (push s tag)
                  (push s ">"))
              (push s elem)))
        (if (symbol? elem)
            (push s elem)
          (push s (escape elem)))))
    `(apply concat
      ,(apply (lambda (&rest r) r) s))))
