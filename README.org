#+TITLE: SPAIK

The *SPAIK*-LISP programming language, a dynamic extension language for Rust
applications.

*SPAIK* compiles to bytecode which is executed by the Rodent VM, and uses a
moving garbage collector called NUKE. In addition to standard affairs like loops
and conditionals it has iterators, continuations, and of course macros. The
following somewhat long example showcases many of its features.

#+begin_src lisp
(defvar history (new-history))

(defun funky (track)
  (let ((volume (yield '(how-loud))))
    (play-funk track)
    (add-to-history history track)
    (let ((adjective (if (> volume 50)
                         "loudly"
                       "softly")))
      (fmt "Playing {track} {adjective}"))))
#+end_src

#+begin_src rust
use spaik::{Spaik, EnumCall, Promise, Fissile, spaikfn};
use serde::Deserialize;

// SPAIK makes it easy to implement the command-pattern using call-by-enum
#[derive(EnumCall)]
enum Command {
    Funky(i32),
}

// We use serdes Deserialize trait to construct complex Rust types from s-expressions
#[derive(Deserialize)]
enum Response {
    HowLoud,
}

// We'll be putting some functions into `Fns`
struct Fns;

// In order to work with this `History` struct
#[derive(Fissile)]
struct History {
    tracks: Vec<String>
}

// One for adding history
#[spaikfn(Fns)]
fn add_to_history(hist: &mut History, item: String) {
    hist.tracks.push(item);
}

// One for creating the `History` struct
#[spaikfn(Fns)]
fn new_history() -> History {
    History { tracks: vec![] }
}

fn api_func_call() -> Result<(), Box<dyn std::error::Error>> {
    let mut vm = Spaik::new()?;

    // We'll register the functions so that they're callable from SPAIK
    vm.register(Fns::add_to_history)?;
    vm.register(Fns::new_history)?;

    // Then we set up the load-path and load the script
    vm.add_load_path("examples")?;
    vm.load("funk.lisp")?;

    // Reference to heap-allocated SPAIK objects are made using `Gc<T>`
    let hist: Gc<History> = vm.get("history")?;

    // Call-by-enum, and get a continuation.
    let cont: Promise<Response> = vm.query(Command::Funky(60))?;

    // You'll notice that a lot of the calls follow the pattern:
    //   `let resp: ExpectedType = vm.method(...)?`
    // Here `ExpectedType` is a type-guard, and `vm.method(...)` will return an
    // error if it can't convert the SPAIK value to the expected Rust type.

    // Fulfil promise
    let res: String = vm.fulfil(cont, String::from("funky.mp3"))?;
    assert_eq!(&*res, "Playing funky.mp3 loudly");

    // Set history to nil and make sure the GC notices
    vm.set("history", ());
    vm.gc();
    // The Gc<History> smart-pointer makes sure the object is not deallocated
    // Access is done using `.with()` because of Rusts strict aliasing rules.
    assert!(hist.with(|h| h.tracks.last() == Some("funky.mp3")));

    // Gc<History> gets dropped here, but it could outlive `vm` if we wanted it to.
}
#+end_src

* What can I use this for?
*SPAIK* is designed as an embedded scripting language. Its goal is to be
reasonably performant, like PUC Lua, but unlike PUC Lua it aims to have a safe
and simple API.

In short, use it for things like scripting behavior in games, or automating
applications.

* More Examples
See ~lisp/test.lisp~ and the ~tests/*.lisp~ files for an example of a non-trivial
macro, and ~lisp/self.lisp~ for a non-trivial program. You can also check out
the standard library at ~lisp/stdlib.lisp~.

* Trivia
The SPAIK VM is referred to in code as ~r8vm~, and in speech as "The Rodent
Virtual Machine" or "Rodent VM". This is a pun on V8, and the fact that R8 is
pronounced like "rotte" in Norwegian, meaning "rat."

The SPAIK GC is referred to as the "Nuclear Garbage Collector," I find it
fitting both because it is a compacting garbage collector, which is kind of the
nuclear solution to memory fragmentation. But also because of the association
between radioactivity and ~unsafe~ in Rust, and ~nkgc~ contains a lot of that.
The nuclear theme carries over into the ~Fissile~ trait, and ~Fissile~
derive-macro for values that can be stored in the SPAIK heap (the ~nuke~, if you
will.)
