#+TITLE: SPAIK

The *SPAIK*-LISP programming language, with a [[https://moesys.no/en/#spaik][live webassembly demo]]! Here's some
Rust code calling a *SPAIK* function:

#+begin_src lisp
(defun plus (&rest xs)
  (let ((s 0))
    (dolist (x xs)
      (set s (+ s x)))
    s))
#+end_src

#+begin_src rust
use spaik::spaik::Spaik;
use spaik::error::Error;

fn api_func_call() -> Result<(), Error> {
    let mut vm = Spaik::new()?;
    vm.load("plus")?;
    let (x, y, z) = (1, 2, 3);
    let result: i32 = vm.call("plus", (x, y, z, 4, 5))?;
    assert_eq!(result, 15);
}
#+end_src

*SPAIK* compiles to bytecode which is executed by its VM, and uses a moving
garbage collector. In addition to standard affairs like loops and conditionals
it has iterators, continuations, and of course macros.

When using *SPAIK* you should rely only on the ~spaik::spaik~ module, which is
the public API. This will eventually become the top-level crate of *SPAIK*, but
the repository has not yet been split into multiple crates.

* What can I use this for?
*SPAIK* is designed as an embedded scripting language. Its goal is to be
reasonably performant, like PUC Lua, but unlike PUC Lua it aims to have a safe
and simple API.

In short, use it for things like scripting behavior in games, or automating
applications.

*SPAIK* is not designed to be sandboxed. Strictly speaking there is nothing
preventing you from creating a *SPAIK* environment without any access to the
outside world by removing built-in IO functions. But because the *SPAIK*
implementation does things like implementing its own garbage collector, it
contains unaudited unsafe code.

* More Examples
See ~lisp/test.lisp~ and the ~tests/*.lisp~ files for an example of a non-trivial
macro, and ~lisp/self.lisp~ for a non-trivial program. You can also check out
the standard library at ~lisp/stdlib.lisp~.
