#+TITLE: SPAIK

The *SPAIK*-LISP programming language, with a [[https://moesys.no/en/#spaik][live webassembly demo]]! Here's a
somewhat complex example showcasing some of SPAIKs features.

#+begin_src lisp
(defvar history (new-history))

(defun funky (track)
  (let ((volume (yield '(how-loud))))
    (play-funk track)
    (add-to-history history track)
    (let ((adjective (if (> volume 50)
                         "loudly"
                       "softly")))
      (fmt "Playing {track} {adjective}"))))
#+end_src

#+begin_src rust
use spaik::{Spaik, EnumCall, Promise, Fissile, spaikfn};
use serde::Deserialize;

// SPAIK makes it easy to implement the command-pattern using call-by-enum
#[derive(EnumCall)]
enum Command {
    Funky(i32),
}

// We use serdes Deserialize trait to construct complex Rust types from s-expressions
#[derive(Deserialize)]
enum Response {
    HowLoud,
}

// We'll be putting some functions into `Fns`
struct Fns;

// In order to work with this `History` struct
#[derive(Fissile)]
struct History {
    tracks: Vec<String>
}

// One for adding history
#[spaikfn(Fns)]
fn add_to_history(hist: &mut History, item: String) {
    hist.tracks.push(item);
}

// One for creating the `History` struct
#[spaikfn(Fns)]
fn new_history() -> History {
    History { tracks: vec![] }
}

fn api_func_call() -> Result<(), Box<dyn std::error::Error>> {
    let mut vm = Spaik::new()?;

    // We'll register the functions so that they're callable from SPAIK
    vm.register(Fns::add_to_history)?;
    vm.register(Fns::new_history)?;

    // Then we set up the load-path and load the script
    vm.add_load_path("examples")?;
    vm.load("funk.lisp")?;

    // Reference to heap-allocated SPAIK objects
    let hist: Gc<History> = vm.get("history")?;

    // Call-by-enum, and get a continuation
    let cont: Promise<Response> vm.query(Command::Funky(60))?;

    // Fulfil promise
    let res: String = vm.fulfil(cont, String::from("funky.mp3"))?;
    assert_eq!(&*res, "Playing funky.mp3 loudly");

    // Set history to nil and make sure the GC notices
    vm.set("history", ());
    vm.gc();
    // The Gc<History> smart-pointer makes sure the object is not deallocated
    // Access is done using `.with()` because of Rusts strict aliasing rules.
    assert!(hist.with(|h| h.tracks.last() == Some("funky.mp3")));

    // Gc<History> gets dropped here, but it could outlive `vm` if we wanted to.
}
#+end_src

*SPAIK* compiles to bytecode which is executed by its VM, and uses a moving
garbage collector. In addition to standard affairs like loops and conditionals
it has iterators, continuations, and of course macros.

* What can I use this for?
*SPAIK* is designed as an embedded scripting language. Its goal is to be
reasonably performant, like PUC Lua, but unlike PUC Lua it aims to have a safe
and simple API.

In short, use it for things like scripting behavior in games, or automating
applications.

* More Examples
See ~lisp/test.lisp~ and the ~tests/*.lisp~ files for an example of a non-trivial
macro, and ~lisp/self.lisp~ for a non-trivial program. You can also check out
the standard library at ~lisp/stdlib.lisp~.
