#+TITLE: SPAIK

The *SPAIK*-LISP programming language, a dynamic extension language for Rust
applications.

*SPAIK* compiles to bytecode which is executed by the Rodent VM, and uses a
moving garbage collector called NUKE. In addition to standard affairs like loops
and conditionals it has iterators, continuations, and of course macros. The
following somewhat long example showcases many of its features.

#+begin_src lisp
(defvar history (new-history))

(defun funky (track)
  (let ((volume (yield '(how-loud))))
    (play-funk track)
    (add-to-history history track)
    (let ((adjective (if (> volume 50)
                         "loudly"
                       "softly")))
      (fmt "Playing {track} {adjective}"))))
#+end_src

#+begin_src rust
use spaik::{Spaik, EnumCall, Promise, Fissile, spaikfn};
use serde::Deserialize;

// SPAIK makes it easy to implement the command-pattern using call-by-enum
#[derive(EnumCall)]
enum Command {
    Funky(i32),
}

// We use serdes Deserialize trait to construct complex Rust types from s-expressions
#[derive(Deserialize)]
enum Response {
    HowLoud,
}

// We'll be putting some functions into `Fns`
struct Fns;

// In order to work with this `History` struct
#[derive(Fissile)]
struct History {
    tracks: Vec<String>
}

// One for adding history
#[spaikfn(Fns)]
fn add_to_history(hist: &mut History, item: String) {
    hist.tracks.push(item);
}

// One for creating the `History` struct
#[spaikfn(Fns)]
fn new_history() -> History {
    History { tracks: vec![] }
}

fn api_func_call() -> Result<(), Box<dyn std::error::Error>> {
    let mut vm = Spaik::new()?;

    // We'll register the functions so that they're callable from SPAIK
    vm.register(Fns::add_to_history)?;
    vm.register(Fns::new_history)?;

    // Then we set up the load-path and load the script
    vm.add_load_path("examples")?;
    vm.load("funk")?;

    // Reference to heap-allocated SPAIK objects are made using `Gc<T>`
    let hist: Gc<History> = vm.get("history")?;

    // Call-by-enum, and get a continuation.
    let cont: Promise<Response> = vm.query(Command::Funky(60))?;

    // You'll notice that a lot of the calls follow the pattern:
    //   `let resp: ExpectedType = vm.method(...)?`
    // Here `ExpectedType` is a type-guard, and `vm.method(...)` will return an
    // error if it can't convert the SPAIK value to the expected Rust type.

    // Fulfil promise
    let res: String = vm.fulfil(cont, String::from("funky.mp3"))?;
    assert_eq!(&*res, "Playing funky.mp3 loudly");

    // Set history to nil and make sure the GC notices
    vm.set("history", ());
    vm.gc();
    // The Gc<History> smart-pointer makes sure the object is not deallocated
    // Access is done using `.with()` because of Rusts strict aliasing rules.
    assert!(hist.with(|h| h.tracks.last() == Some("funky.mp3")));

    // Gc<History> gets dropped here, but it could outlive `vm` if we wanted it to.
}
#+end_src

* What can I use this for?
*SPAIK* is designed as an embedded scripting language. Its goal is to be
reasonably performant, like PUC Lua, but unlike PUC Lua it aims to have a safe
and simple API. There are already other embedded scripting languages for Rust
with this same goal, use *SPAIK* if you like its API or if performance is better
on SPAIK for your use-case.

In short, use it for things like scripting behavior in games, or automating
applications.

* Games and other soft real-time apps
If your game is not very demanding, running SPAIK code in the main loop might be
acceptable. But SPAIK also supports an alternate asynchronous methdod of
operation, based on the command-pattern.

The way it works, is that you call ~fork~ on a ~Spaik~ struct. This gives you a
~SpaikPlug~ that you can send commands to, these commands correspond to
functions in your script. The scripts can also send messages back to the main
thread, and can additionally ~await~ responses to their messages.

#+begin_src lisp
(defvar init-var nil)

(defun init () (set init-var 'init))

(defun event-0 (x)
  (let ((res (await '(test :id 1337))))
    (set init-var (+ res x 1))))
#+end_src

#+begin_src rust
#[derive(Debug, Deserialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "kebab-case")]
enum Msg {
    Test { id: i32 },
}

#[derive(Debug, Deserialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "kebab-case")]
enum Cmd {
    Event0(i32),
}

fn api_func_call() -> Result<(), Box<dyn std::error::Error>> {
    let mut vm = Spaik::new();
    vm.load("async-example");
    let mut vm = vm.fork::<Msg, Cmd>();

    // Send commands
    vm.cmd(Cmd::Event0(123));

    // ... Later on
    let p = vm.recv();
    assert_eq!(p.get(), &Msg::Test { id: 1337 });
    let fulfil_res = 31337;
    vm.fulfil(p, fulfil_res);

    // We can join with the VM again on the same thread
    let mut vm = vm.join();
    let init_var: i32 = vm.eval("init-var").unwrap();
    assert_eq!(init_var, fulfil_res + ev0_arg + 1);
}
#+end_src

* More Examples
See ~lisp/test.lisp~ and the ~tests/*.lisp~ files for an example of a non-trivial
macro, and ~lisp/self.lisp~ for a non-trivial program. You can also check out
the standard library at ~lisp/stdlib.lisp~.

* Trivia
The SPAIK VM is referred to in code as ~r8vm~, and in speech as "The Rodent
Virtual Machine" or "Rodent VM". This is a pun on V8, and the fact that R8 is
pronounced like "rotte" in Norwegian, meaning "rat."

The SPAIK GC is referred to as the "Nuclear Garbage Collector," I find it
fitting both because it is a compacting garbage collector, which is kind of the
nuclear solution to memory fragmentation. But also because of the association
between radioactivity and ~unsafe~ in Rust, and ~nkgc~ contains a lot of that.
The nuclear theme carries over into the ~Fissile~ trait, and ~Fissile~
derive-macro for values that can be stored in the SPAIK heap (the ~nuke~, if you
will.)
